[openfl.display.Shader] ERROR: Error compiling fragment shader
0(134) : warning C1503: undefined variable "iTime"
0(144) : warning C1503: undefined variable "iTime"
0(152) : warning C1503: undefined variable "iResolution"
0(152) : warning C1503: undefined variable "iResolution"
0(134) : error C1008: undefined variable "iTime"
0(144) : error C1008: undefined variable "iTime"
0(152) : error C1008: undefined variable "iResolution"
0(152) : error C1008: undefined variable "iResolution"

#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#endif

varying float openfl_Alphav;
		varying vec4 openfl_ColorMultiplierv;
		varying vec4 openfl_ColorOffsetv;
		varying vec2 openfl_TextureCoordv;

		uniform bool openfl_HasColorTransform;
		uniform vec2 openfl_TextureSize;
		uniform sampler2D bitmap;

		uniform bool hasTransform;
		uniform bool hasColorTransform;

		vec4 flixel_texture2D(sampler2D bitmap, vec2 coord)
		{
			vec4 color = texture2D(bitmap, coord);

			if (!hasTransform)
			{
				return color;
			}

			if (color.a == 0.0)
			{
				return vec4(0.0, 0.0, 0.0, 0.0);
			}

			if (!hasColorTransform)
			{
				return color * openfl_Alphav;
			}

			color = vec4(color.rgb / color.a, color.a);

			mat4 colorMultiplier = mat4(0);
			colorMultiplier[0][0] = openfl_ColorMultiplierv.x;
			colorMultiplier[1][1] = openfl_ColorMultiplierv.y;
			colorMultiplier[2][2] = openfl_ColorMultiplierv.z;
			colorMultiplier[3][3] = openfl_ColorMultiplierv.w;

			color = clamp(openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);

			if (color.a > 0.0)
			{
				return vec4(color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);
			}

			return vec4(0.0, 0.0, 0.0, 0.0);
		}

#define SPLAT_MULT 4.0

vec2 rotateUV(vec2 uv, float rot) {
    vec3 t = vec3(sin(rot), cos(rot), 0.0);
    t.z = -t.x;
    uv = t.yy * uv.xy + t.xz * uv.yx;
    return uv;
}

float sdStar(vec2 p, float r, float n, float m) {
    float an = 3.14159265358979 / n;
    float en = 3.14159265358979 / m;
    vec2  acs = vec2(cos(an), sin(an));
    vec2  ecs = vec2(cos(en), sin(en));
    float l = length(p);
    float a = atan(p.y, p.x);
    float d = cos(floor(0.5 + a / an) * an - a) * l;
    d = pow(abs(d), 0.9);
    return d - r;
}

// Hash functions from ShaderToy
float hash12(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

vec3 hash32(vec2 p) {
    return fract(sin(vec3(dot(p, vec2(127.1, 311.7)),
                          dot(p, vec2(269.5, 183.3)),
                          dot(p, vec2(419.2, 371.9)))) * 43758.5453);
}

vec4 hash43(vec3 p) {
    return fract(sin(vec4(dot(p, vec3(127.1, 311.7, 74.7)),
                          dot(p, vec3(269.5, 183.3, 246.1)),
                          dot(p, vec3(419.2, 371.9, 129.3)),
                          dot(p, vec3(13.5, 37.2, 83.1)))) * 43758.5453);
}

vec3 hsl2rgb(float h, float s, float l) {
    float c = (1.0 - abs(2.0 * l - 1.0)) * s;
    float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
    float m = l - 0.5 * c;

    vec3 rgb;
    if (h < 1.0 / 6.0)      rgb = vec3(c, x, 0.0);
    else if (h < 2.0 / 6.0) rgb = vec3(x, c, 0.0);
    else if (h < 3.0 / 6.0) rgb = vec3(0.0, c, x);
    else if (h < 4.0 / 6.0) rgb = vec3(0.0, x, c);
    else if (h < 5.0 / 6.0) rgb = vec3(x, 0.0, c);
    else                   rgb = vec3(c, 0.0, x);

    return rgb + vec3(m);
}

vec3 sparkle(vec2 p, vec2 cell, float phase) {
    vec2 uv = p - 1.0;
    vec4 rand = hash43(vec3(cell, floor((phase + 1.0) / 2.0)));

    float rot = rand.w + sign(rand.w - 0.5) * phase * 1.3;
    vec2 offset = rand.yz * 0.7;
    uv = rotateUV(uv + offset, rot);

    float size = rand.x;
    float sizeMod = 0.5 * cos(phase * 3.14159265) + 0.5;
    size *= sizeMod;

    float d = sdStar(uv, 0.4 * size, 4.0, 0.6 - sizeMod * 0.3);
    float star = smoothstep(-0.01, -0.02, d);
    float glow = smoothstep(-0.1 + sizeMod * 0.2, -0.1, d) * 0.15;
    
    vec3 col = mix(hsl2rgb(fract(phase * 1.4), 1.0, 0.6), vec3(1.0), sizeMod);
    return col * (star + glow);
}

vec3 sparkleLayer(vec2 uv, vec2 vel, float phase) {
    uv += vel * iTime;

    vec2 splatuv = fract(uv * SPLAT_MULT / 2.0);
    vec2 cell = floor(uv * SPLAT_MULT / 2.0);

    vec3 col = vec3(0.0);
    for (int x = -1; x <= 1; ++x)
    for (int y = -1; y <= 1; ++y)
    {
        vec2 offset = vec2(x, y);
        col += sparkle(splatuv - offset, cell + offset, 2.0 * iTime + hash12(cell + offset) * 4.0 + phase);
    }

    return col;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 2.0;
    
    vec3 col = sparkleLayer(uv, vec2(0.2, 0.1), 0.0);
    col += sparkleLayer(uv, vec2(-0.01, -0.13), 1.0);
    col += sparkleLayer(uv, vec2(-0.06, 0.2), 2.0);

    fragColor = vec4(col, 1.0);
}
